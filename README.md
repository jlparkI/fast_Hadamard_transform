# fast_Hadamard_transform

[Overview](#Overview)<br>
[Speed Compare](#Speed_Compare)<br>
[Installation](#Installation)<br>
[Use](#Use)

### Overview
This module is Python-wrapped C code to perform an unnormalized fast Hadamard transform
on a 1d or 2d array. This will yield the same result as multiplying by a matrix generated by scipy.linalg.hadamard (this procedure is used for testing) but has O(N log(N)) scaling rather
than O(N^2), so for large arrays it's dramatically faster.

When performing the transform on a 2d array, the transform is performed on each row of the array (as if each row were a vector to be transformed).

This module will expect the input array to be a numpy array, of type np.float64, for which shape[0] is a power of 2. It will raise an exception if you give it anything else. If the size of your array is not a power of 2, you can zero-pad it before feeding it to this function.

The Hadamard transform, although less well-known and less popular than FFT, is useful for a variety of purposes, especially for certain algorithms for approximating Gaussian processes (e.g. the FastFood kernel algorithms).

### Speed_Compare
Check out the time_test in the tests folder. YMMV, but on my machine here are a few time comparisons using timeit:

| Array Size | Time for Scipy (s) | Time for fast_Hadamard |
| ---------- | ------------------ | ---------------------- |
| 256 | 0.0316 | 0.00131 |
| 1024 | 0.309 | 0.0017 |
| 2048 | 1.3874 | 0.00241 |

Of course, this does include for scipy the time it takes scipy to generate the Hadamard
array before doing the matrix multiplication. But that's a necessary part of the cost of the
transform if you're doing it by generating a Hadamard matrix first (as scipy is).

### Installation
Clone the repo, activate your favorite venv and from your command line run:
```
python setup_hadamard_transformmodule.py install
```
You can use pip to uninstall if so desired. To run the unittest, go to the tests folder and run:
```
python unittest_hadamard_transformmodule.py
```
the test will check that the module is working and gives the same results as scipy for a randomly populated array.

### Use
```
import fastHadamardTransform
from fastHadamardTransform import fastHadamardArray, fastHadamard2dArray

arrayIWantToTransform = rng.uniform(low=-10,high=10, size=(256))
fastHadamardArray(corrected_arr)
```
and that's all there is to it. Notice that the transform is performed in-place; this provides a small additional performance gain, but of course be aware of this if passing an array you are planning to modify later.
